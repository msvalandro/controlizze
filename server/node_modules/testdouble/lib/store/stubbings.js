'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require('../wrap/lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _argsMatch = require('../args-match');

var _argsMatch2 = _interopRequireDefault(_argsMatch);

var _isCallback = require('../matchers/is-callback');

var _isCallback2 = _interopRequireDefault(_isCallback);

var _notifyAfterSatisfaction = require('../matchers/notify-after-satisfaction');

var _notifyAfterSatisfaction2 = _interopRequireDefault(_notifyAfterSatisfaction);

var _config = require('../config');

var _config2 = _interopRequireDefault(_config);

var _log = require('../log');

var _log2 = _interopRequireDefault(_log);

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

exports.default = {
  add: function add(testDouble, args, stubbedValues, config) {
    return _index2.default.for(testDouble).stubbings.push({
      callCount: 0,
      stubbedValues: stubbedValues,
      args: args,
      config: config
    });
  },
  invoke: function invoke(testDouble, actualArgs, actualContext) {
    var stubbing = stubbingFor(testDouble, actualArgs);
    if (stubbing) {
      (0, _notifyAfterSatisfaction2.default)(stubbing.args, actualArgs);
      return executePlan(stubbing, actualArgs, actualContext);
    }
  },
  for: function _for(testDouble) {
    return _index2.default.for(testDouble).stubbings;
  }
};


var stubbingFor = function stubbingFor(testDouble, actualArgs) {
  return _lodash2.default.findLast(_index2.default.for(testDouble).stubbings, function (stubbing) {
    return isSatisfied(stubbing, actualArgs);
  });
};

var executePlan = function executePlan(stubbing, actualArgs, actualContext) {
  var value = stubbedValueFor(stubbing);
  stubbing.callCount += 1;
  invokeCallbackFor(stubbing, actualArgs);
  switch (stubbing.config.plan) {
    case 'thenReturn':
      return value;
    case 'thenDo':
      return value.apply(actualContext, actualArgs);
    case 'thenThrow':
      throw value;
    case 'thenResolve':
      return createPromise(stubbing, value, true);
    case 'thenReject':
      return createPromise(stubbing, value, false);
  }
};

var invokeCallbackFor = function invokeCallbackFor(stubbing, actualArgs) {
  if (_lodash2.default.some(stubbing.args, _isCallback2.default)) {
    _lodash2.default.each(stubbing.args, function (expectedArg, i) {
      if ((0, _isCallback2.default)(expectedArg)) {
        callCallback(stubbing, actualArgs[i], callbackArgs(stubbing, expectedArg));
      }
    });
  }
};

var callbackArgs = function callbackArgs(stubbing, expectedArg) {
  if (expectedArg.args != null) {
    return expectedArg.args;
  } else if (stubbing.config.plan === 'thenCallback') {
    return stubbing.stubbedValues;
  } else {
    return [];
  }
};

var callCallback = function callCallback(stubbing, callback, args) {
  if (stubbing.config.delay) {
    _lodash2.default.delay.apply(_lodash2.default, [callback, stubbing.config.delay].concat(_toConsumableArray(args)));
  } else if (stubbing.config.defer) {
    _lodash2.default.defer.apply(_lodash2.default, [callback].concat(_toConsumableArray(args)));
  } else {
    callback.apply(undefined, _toConsumableArray(args)); // eslint-disable-line
  }
};

var createPromise = function createPromise(stubbing, value, willResolve) {
  var Promise = (0, _config2.default)().promiseConstructor;
  ensurePromise(Promise);
  return new Promise(function (resolve, reject) {
    callCallback(stubbing, function () {
      return willResolve ? resolve(value) : reject(value);
    }, [value]);
  });
};

var stubbedValueFor = function stubbedValueFor(stubbing) {
  return stubbing.callCount < stubbing.stubbedValues.length ? stubbing.stubbedValues[stubbing.callCount] : _lodash2.default.last(stubbing.stubbedValues);
};

var isSatisfied = function isSatisfied(stubbing, actualArgs) {
  return (0, _argsMatch2.default)(stubbing.args, actualArgs, stubbing.config) && hasTimesRemaining(stubbing);
};

var hasTimesRemaining = function hasTimesRemaining(stubbing) {
  return stubbing.config.times == null ? true : stubbing.callCount < stubbing.config.times;
};

var ensurePromise = function ensurePromise(Promise) {
  if (Promise == null) {
    return _log2.default.error('td.when', 'no promise constructor is set (perhaps this runtime lacks a native Promise\nfunction?), which means this stubbing can\'t return a promise to your\nsubject under test, resulting in this error. To resolve the issue, set\na promise constructor with `td.config`, like this:\n\n  td.config({\n    promiseConstructor: require(\'bluebird\')\n  })');
  }
};